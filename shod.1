.TH SHOD 1
.SH NAME
.B shod
\- hybrid window manager
.SH SYNOPSIS
.B shod
.SH DESCRIPTION
.B shod
is an hybrid (tiling and floating) multimonitor X11 window manager.
.B shod
sets no keybindings;
reads no configuration other than X resources;
and works only via mouse with a given key modifier (Alt by default)
and by responding to client messages with EWMH hints
(so you have to use
.IR wmctrl (1)
to control shod).
.PP
.B shod
maintains one monitor for each physical monitor found by
.IR Xinerama (1).
One of the monitors is the focused one, where new windows go to when they are created.
Each monitor contains a set of desktops.
One of the desktops of a monitor is the focused desktop for that monitor.
.B shod
manages desktop just like how GNOME implements \(lqactions\(rq.
If a window is open on the last empty desktop,
.B shod
creates a new empty desktop on that monitor.
When a desktop has no window, this desktop is deleted.
.PP
Each window has one of the following four states:
.TP
Minimized
Minimized windows belong to no monitor or desktop.
Minimized windows are not shown on the screen.
When a minimized window is unminimized,
it becomes a normal window on the focused desktop of the focused monitor.
.TP
Sticky
Sticky windows belong only to a monitor; but they do not belong to any desktop.
Instead, they are \(dqsticked\(dq to the monitor, and they appear on the screen
no matter which desktop is focused on that monitor.
.TP
Tiled
Tiled windows belong to a desktop and its monitor.
The monitor is divided into columns, each window occupies a row in a column.
(This tiling style is the same used by the old wmii(1) window manager and the acme(1) editor).
.TP
Normal
Normal windows belong to a desktop and its monitor.
Normal windows, just like sticky windows, are floating windows.
Normal windows appear only when its desktop is the focused one for its monitor.
.PP
A non-minimized window can also be made fullscreen.
A floating (sticky or normal) window can also be raised above other floating windows
or lowered below other floating windows.
.PP
When a new window spawns, it is set as
.BR Normal ,
and it is placed in an unoccupied region of the monitor.
The window in a monitor is spawned in the center of the monitor.
.PP
The window stacking order is the following (from bottom-to-top):
.IP \(bu 2
Tiled windows appear below any other windows.
.IP \(bu 2
Lowered floating windows appear on top of tiled windows.
.IP \(bu 2
Regular floating windows appear on top of lowered floating windows.
.IP \(bu 2
Raised floating windows appear on top of regular floating windows.
.IP \(bu 2
Fullscreen windows appear on top of raised floating windows.
.SH USAGE
.B shod
has several ways of manipulating windows.
See the section
.B EXAMPLES
for examples on how to use
.IR wmctrl (1)
for controlling shod.
.SS Manipulating with the mouse
The main method for controlling windows is the mouse.
.PP
The
.B config.focusbuttons
variable (set at compile time in config.h)
specifies which mouse buttons can be used to focus a window when clicking on it.
Each bit represents a button.
For example, if it is set to 5 (0101 in binary),
a window is focused when clicking on it with the first or the third mouse button.
If this variable is set to 0, the focus follows the mouse pointer.
.PP
The
.B config.raisebuttons
variable (set at compile time in config.h)
specifies which mouse buttons can be used to raise a window when clicking on it.
Each bit represents a button.
If this variable is set to 0, all buttons raises a window.
.PP
The
.B config.modifier
variable (set at compile time in config.h)
specifies the modifier key.
Pressing the modifier key and dragging a window with the Button 1
(the left mouse button) will move that window.
Pressing the modifier key and dragging a corner or side of a window with the Button 3
(the right mouse button) will resize that window in the direction of that corner or side.
.PP
Resizing windows can also be performed by dragging a window border with the Button 1,
without pressing any modifier.
Moving windows can also be performed by dragging a window border with the button 3,
without pressing any modifier.
.SS Manipulating via window properties
The
.IR wmctrl (1)
utility can be used to set window properties,
and
.B shod
respects and sets those properties in different ways.
For example, running the following command toggles the sticky option
on the active window.
.IP
.EX
$ wmctrl -r :ACTIVE: -b toggle,sticky
.EE
.IP \(bu 2
If the
.B sticky
property is set on a window, this window becomes sticky
(it is displayed on all desktops of the monitor the window is in).
.IP \(bu 2
If the
.BR maximize_vert " and " maximize_horz
properties are set on a window, the window is tiled.
For more information on manipulating tiled windows, see the section
.B Manipulating tiled windows
below.
.IP \(bu 2
If the
.B hidden
property is set on a window,
the window becomes minimized
(it won't be displayed on any desktop or on any monitor).
.IP \(bu 2
If the
.B fullscreen
property is set on a window, the window is maximized to fit the entire screen.
.IP \(bu 2
If the
.B above
property is set on a floating window, the window is raised above all other floating windows.
.IP \(bu 2
If the
.B below
property is set on a floating window, the window is lowered below all other floating windows.
.PP
All other properties are ignored.
.SS Manipulating via other client messages
.B shod
acts upon other client messages sent to windows and to the root window.
Most client messages can be sent via
.IR wmctrl (1)
with a specific option.
The options and the messages they send are specified below.
.IP \(bu 2
A message sent with the
.BI -s " NUMBER"
option of
.IR wmctrl (1)
makes
.B shod
changes the desktop.
That is,
hide the windows on the current desktop and show the windows on a new desktop.
If the desktop is on another monitor,
.B shod
instead move the pointer to that monitor and focus a window on it.
.IP \(bu 2
A message sent with the
.B -k on
or
.B -k off
options of
.IR wmctrl (1)
makes
.B shod
show or hide the desktop, respectively.
.IP \(bu 2
A message sent with the
.BI -a " WINDOW"
option of
.IR wmctrl (1)
makes
.B shod
change the active window.
That is, focus and raise the specified window.
.IP \(bu 2
A message sent with the
.BI -c " WINDOW"
option of
.IR wmctrl (1)
makes
.B shod
close gently the specified window.
.IP \(bu 2
A message sent with the
.BI -e " POSITION"
option of
.IR wmctrl (1)
makes
.B shod
change the position and geometry of the specified window.
.IP \(bu 2
A message sent with the
.BI -s " NUMBER"
option of
.IR wmctrl (1)
makes
.B shod
send a specified window to a specified desktop.
.IP \(bu 2
A message sent with the
.BI -t " NUMBER"
option of
.IR wmctrl (1)
makes
shod
move the specified window to the specified desktop.
.SS Manipulating via configure request
.B shod
acts upon configure request events sent to windows via utilities by resizing and moving windows
just as if the user have resized or moved them with the mouse.
For more information, on how to do this, see the manual of these utilities.
.PP
When a window is moved from one monitor to another,
that window moves from the desktop it is in to the focused desktop
of the monitor it is moved to.
.SS Manipulating tiled windows
When a window is maximized, it is tiled by
.BR shod .
A tiled window behaves differently of regular windows.
The tiled windows are organized in columns.
Each tiled window ocupies a row in a column.
.PP
In order to move a tiled window from one column to another
just move the window left or right with
.IR wmctrl (1).
This will move the window from its current column to the column to its
left or right, or it will create a new column, if needed.
.PP
In order to move a tiled window up or down a column,
just move the window up or down with
.IR wmctrl (1).
.PP
Resizing a tiled window with
.IR wmctrl (1)
or with the Modifier plus the mouse button 3
will change the size of the window, the size of the column it is in,
and the size of the neighboring windows.
.SH ENVIRONMENT
The following environment variables affect the execution of
.B shod
.TP
.B DISPLAY
The display to start
.B shod
on.
.SH RESOURCES
.B shod
understands the following X resources.
.TP
.B shod.borderWidth
The size in pixels of the border around windows.
.TP
.B shod.gapOuter
The gap in pixels between the sides of the monitor and the windows.
.TP
.B shod.gapInner
The gap in pixels between the tiled windows.
.TP
.B shod.ignoreGaps
If set to \(lqtrue\(rq, a single tiled window ingores the gaps.
.TP
.B shod.ignoreBorders
If set to \(lqtrue\(rq, a single tiled window does not have borders.
.TP
.B shod.focused
The color of the focused window.
.TP
.B shod.unfocused
The color of the regular, non-focused windows.
.TP
.B shod.urgent
The color of urgent windows.
.SH EXAMPLES
The following is a sample configuration for X resources.
It must be placed in
.B $HOME/.Xresources
or
.B $HOME/.Xdefaults
or other file called by
.IR xrdb (1).
This example makes shod draw a 3 pixels wide border around windows,
and a 7 pixels wide gap around and between tiled windows.
It sets the color of the border of urgent windows to red;
the border of the focused window to blue;
and the border of regular windows to gray.
.IP
.EX
shod.borderWidth:   3
shod.gapOuter:      7
shod.gapInner:      7
shod.urgent:        #cc0000
shod.focused:       #3465a4
shod.unfocused:     #555753
.EE
.PP
The following is a sample configuration for
.IR sxhkd (1),
a program that binds keypresses (or key releases) to commands.
This example uses
.IR wmctrl (1)
for sending EWMH hints to
.BR shod.
It uses
.IR wmr (1)
(a script shown below) for moving and resizing windows, respectively.
.IP
.EX
# Start terminal (urxvt)
mod1 + Return
	xterm

# Killing windows
mod1 + shift + q
	wmctrl -c :ACTIVE:

# Workspace
mod1 + {1,2,3,4,5,6,7,8,9}
	wmctrl -s {0,1,2,3,4,5,6,7,8,9}
mod1 + shift + {1,2,3,4,5,6,7,8,9}
	wmctrl -r :ACITVE: -t {0,1,2,3,4,5,6,7,8,9}

# Resize/move windows with wmr
mod1 + {c, v, shift + c, shift + v}
	wmr 0 0 {-25 0, 0 -25, +25 0, 0 +25}
mod1 + shift + {h, j, k, l}
	wmr {-10 0, 0 10, 0 -10, 10 0} 0 0

# Change window status to sticky/above/below/minimized/fullscreen/maximized
mod1 + shift + {s, a, b, z, f}
	wmctrl -r :ACTIVE: -b toggle,{sticky,above,below,hidden,fullscreen}
mod1 + shift + t
	wmctrl -r :ACTIVE: -b toggle,maximized_vert,maximized_horz

# Call the unminimize.sh script
mod1 + shift + u
	unminimize.sh
.EE
.PP
The previous example binds the following keys to the following commands:
.TP
.B Mod4 + Enter
Spawns a terminal emulator window.
.TP
.B Mod4 + Shift + Q
Gently closes the active windows.
.TP
.B Mod4 + <N>
Go to the N-th desktop.
.TP
.B Mod4 + Shift + <N>
Send active window to the N-th desktop.
.TP
.B Mod4 + C
Shrink the active window horizontally by 25 pixels.
.TP
.B Mod4 + Shift + C
Expand the active window horizontally by 25 pixels.
.TP
.B Mod4 + V
Shrink the active window vertically by 25 pixels.
.TP
.B Mod4 + Shift + V
Expand the active window vertically by 25 pixels.
.TP
.B Mod4 + Shift + H
Move the active window 10 pixels to the left.
.TP
.B Mod4 + Shift + J
Move the active window 10 pixels down.
.TP
.B Mod4 + Shift + K
Move the active window 10 pixels up.
.TP
.B Mod4 + Shift + L
Move the active window 10 pixels to the right.
.TP
.B Mod4 + Shift + S
Make the active window sticky;
or make it normal if it was sticky.
.TP
.B Mod4 + Shift + A
Raise the active window above the others;
or move it to its normal place if it was already above others.
.TP
.B Mod4 + Shift + B
Lower the active window below the others;
or move it to its normal place if it was already below others.
.TP
.B Mod4 + Shift + Z
Hide the active window.
.TP
.B Mod4 + Shift + F
Make the active window fullscreen;
or make it normal if it was already fullscreen.
.TP
.B Mod4 + Shift + T
Tile the active window;
or make it floating if it was already tiled.
.TP
.B Mod4 + Shift + U
Call the unminimize.sh script (see below).
.PP
The following is a sample script for
.IR dmenu (1).
This script lists the minimized windows and unminimizes the selected one.
This script uses
.IR xprop (1)
to obtain the X properties set by
.BR shod.
.IP
.EX
#!/bin/sh

lsw() {
	xprop -notype -f "_NET_CLIENT_LIST" 0x \(aq $0+\en\(aq -root "_NET_CLIENT_LIST" |\e
	cut -d\(aq \(aq -f2- |\e
	sed \(aqs/, */\e
/g\(aq
}

ishidden() {
	xprop -notype -f "_NET_WM_STATE" 32a \(aq $0+\en\(aq -id "$1" "_NET_WM_STATE" |\e
	cut -d\(aq \(aq -f2- |\e
	sed \(aqs/, */\e
/g\(aq | grep -q "_NET_WM_STATE_HIDDEN"
}

printname() {
	name="$(xprop -notype -f "_NET_WM_NAME" 8s \(aq $0+\en\(aq -id "$1" "_NET_WM_NAME" 2>/dev/null)"
	[ "$(echo $name)" = "_NET_WM_NAME: not found." ] && \e
	name="$(xprop -notype -f "WM_NAME" 8s \(aq $0+\en\(aq -id "$1" "WM_NAME" 2>/dev/null)"

	echo $name |\e
	cut -d\(aq \(aq -f2- |\e
	sed \(aqs/, */\e
/g\(aq
}

for win in $(lsw)
do
	ishidden $win && printf "%s: " $win && printname $win
done |\e
dmenu -i -l 8 -p "unminimize window:" |\e
cut -d: -f1 |\e
xargs wmctrl -b toggle,hidden -ir
.EE
.PP
The following script moves and resize the active window by a relative amount of pixels.
.IP
.EX
#!/bin/sh
# wmr: move and resize window relative to its current position and size

set -e

usage() {
	echo "usage: wmr x y w h" >&2
	exit 1
}

[ $# -ne 4 ] && usage
eval $(xdotool getactivewindow getwindowgeometry --shell)
xadd=$1
yadd=$2
wadd=$3
hadd=$4
X=$(( X + xadd ))
Y=$(( Y + yadd ))
WIDTH=$(( WIDTH + wadd ))
HEIGHT=$(( HEIGHT + hadd ))
wmctrl -r :ACTIVE: -e 0,$X,$Y,$WIDTH,$HEIGHT
.EE
.SH SEE ALSO
.IR dmenu (1),
.IR sxhkd (1),
.IR wmctrl (1),
.SH BUGS
Yes.
